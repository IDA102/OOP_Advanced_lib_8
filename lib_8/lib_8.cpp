//Стандартная библиотека шаблонов - STL 
	//Контейнеры стандартной библиотеки - vector
	//Итераторы
#include "H.h"
ostream& operator<<(ostream& os, const vector <int> &ms)
{
	cout << "______________int______________" << endl;
	cout << "capasity = " << ms.capacity() << endl;
	cout << "size     = " << ms.size() << endl;
	cout << "max_size = " << ms.capacity() << endl;
	for (size_t i = 0; i < ms.size(); i++)
	{
		cout << "[" << i << "]" << "=" << ms[i] << endl;
	}
	cout << endl;
	return os;
};
ostream& operator<<(ostream& os, const vector <double> &ms)
{
	cout << "______________double______________" << endl;
	cout << "capasity = " << ms.capacity() << endl;
	cout << "size     = " << ms.size() << endl;
	cout << "max_size = " << ms.capacity() << endl;
	for (size_t i = 0; i < ms.size(); i++)
	{
		cout << "[" << i << "]" << "=" << ms[i] << endl;
	}
	cout << endl;
	return os;
};
ostream& operator<<(ostream& os, const vector <MyString> &ms)
{
	cout << "______________MyString______________" << endl;
	cout << "capasity = " << ms.capacity() << endl;
	cout << "size     = " << ms.size() << endl;
	cout << "max_size = " << ms.capacity() << endl;
	for (size_t i = 0; i < ms.size(); i++)
	{
		cout << "[" << i << "]" << "=" << ms[i] << endl;
	}
	cout << endl;
	return os;
};
ostream& operator<<(ostream& os, const vector <Point> &ms)
{
	cout << "______________Point______________" << endl;
	cout << "capasity = " << ms.capacity() << endl;
	cout << "size     = " << ms.size() << endl;
	cout << "max_size = " << ms.capacity() << endl;
	for (size_t i = 0; i < ms.size(); i++)
	{
		cout << "[" << i << "]" << "=" << ms[i] << endl;
	}
	cout << endl;
	return os;
};
ostream& operator<<(ostream& os, const vector <Point*>& ms)
{
	cout << "______________Point______________" << endl;
	cout << "capasity = " << ms.capacity() << endl;
	cout << "size     = " << ms.size() << endl;
	cout << "max_size = " << ms.capacity() << endl;
	for (size_t i = 0; i < ms.size(); i++)
	{
		cout << "[" << i << "]" << "=" << ms[i] << endl;
	}
	cout << endl;
	return os;
};

ostream& operator<<(ostream& os, const MyString &ms)
{
	cout << ms.m_pStr;
	return os;
};
ostream& operator<<(ostream& os, const Point &ms)
{
	cout << ms.x << " " << ms.y;
	return os;
}
ostream& operator<<(ostream& os, const Point *ms)
{
	cout << ms->x << " " << ms->y;
	return os;
}

int main()
{
	// Контейнер стандартной библиотеки vector 

//////////////////////////////////////////////////////////////////////
	//Создание векторов. 

	//Создайте следующие вектора:
	//---------------------------
	//пустой вектор целых чисел - vInt и проверьте с помощью функции size(),
	//что его размер нулевой. 
	vector<int> vInt;
	stop
	size_t s = vInt.size();
	stop

	//Раскомментируйте следующий фрагмент, подумайте - все ли корректно
	//Если есть некорректности, - исправьте
	vInt.push_back(0);
	vInt.front()=1;
	int q = vInt.front();
	stop
	/*
	С помощью функции push_back() в цикле заполните вектор какими-либо значениями.
	На каждой итерации цикла следите за размером вектора с помощью методов
	size(), capacity(), max_size() и выводите значения элементов. 
	
	Подсказка: так как такая проверка понадобится Вам и в следующих заданиях,
	напишите шаблон функции, которая для вектора, содержащего элементы любого типа
	выводит его "реквизиты" и значения элементов на консоль.
	*/

	cout << vInt;//Прибавляет +15-20% к capacity
	vInt.push_back(5);
	cout << vInt;
	vInt.push_back(10);
	cout << vInt;
	vInt.push_back(15);
	cout << vInt;
	vInt.push_back(20);
	cout << vInt;
	stop

	/*
	Вектор вещественных - vDouble1 с заданным Вами начальным размером  и
	проверьте результат с помощью созданного Вами шаблона. Как будут
	проинициализированы элементы вектора?
	*/

	vector<double> vDouble1(5);//Нулями // Почему???
	cout << vDouble1;
	stop

	/*
	Bектор объектов типа MyString с начальным размером - 5 элементов
	и инициализацией каждого элемента строкой "A"
	C помощью функции at() а также с помощью оператора
	индексирования []  измените значения каких-либо элементов.
	Попробуйте "выйти" за границы вектора с помощью at() и
	с помощью []. 
	*/
	
	vector<MyString> MS(5,"A");
	stop
	cout << MS << endl;
	stop

	/*
	Bектор вещественных - vDouble3, который является копией элементов
	[0,5) массива вещественных чисел dMas. Предворительно массив dMas
	нужно создать и проинициализировать!
	*/

	double dMas[] = { 1, 2, 3, 4, };
	vector<double> vDouble3(dMas,dMas + sizeof(dMas)/sizeof(double));
	stop

	/*
	Bектор вещественных - vDouble4, который является копией элементов
	[2,5) вектора vDouble3. 
	*/
	vector<double> vDouble4(vDouble3);
	stop
	/*
	Bектор элементов типа Point - vPoint1
	а) с начальным размером 3. Какой конструктор
	будет вызван для каждого элемента?
	b) vPoint2 с начальным размером 5 и проинициализируйте каждый элемент координатами (1,1).
	*/
	
	vector<Point> vPoint1(3); //Будет вызван написаный в Point конструктор;
	stop
	vector<Point> vPoint2(5,Point(1,1));
	cout << vPoint2;
	stop

	/*
	Bектор указателей на Point - vpPoint с начальным размером 5
	Подумайте: как корректно заставить эти указатели "указывать" на объекты Point
			
	Подсказка: для вывода на печать значений скорее всего Вам понадобится
	а) специализация Вашей шаблонной функции
	б) или перегрузка operator<< для Point*
	*/

	{//Что тут требуется?
	vector<Point*> vPoint1(5);// ,new Point());
	stop
	cout << vPoint1 << endl;
	stop
	}//Какие дополнительные действия нужно предпринять для такого вектора?


	///////////////////////////////////////////////////////////////////////
	//Резервирование памяти.
	//Подумайте, всегда ли верны приведенные ниже проверки?
	/*
	{
	size_t n=...
	vector<int> v(n);
	v.resize(n/2);
	if(v.capacity() == n) //true?--------------------------------------Нет (v.capacity > n)
 	}
	*/

	/*
	{
	int n=...
	size_t m=...
	vector<int> v(n);
	v.reserve(m);
	if(v.capacity() == m) //true?--------------------------------------Да
	}
	*/

	/*
	{
	vector<int> v(3,5);---------------------5 5 5
	v.resize(4,10); //значения?-------------5 5 5 10
	v.resize(5); //значения?----------------5 5 5 10 0

	}
	*/

	/*
	Создайте два "пустых" вектора с элементами
	любого (но одного и того же типа) типа.
	В первом векторе зарезервируйте память под 5 элементов, а потом заполните
	его значениями с помощью push_back.
	Второй вектор просто заполните значениями посредством push_back.
		
	Сравните размер, емкость векторов и значения элементов
	*/
	vector<int> v1;
	vector<int> v2;
	stop
	v1.reserve(5);
	cout << v1;
	stop
	size_t N = 5;
		for (size_t i = 0 ; i < N ; i++)//Добавляет по 2 до чётного количества
		{
			v1.push_back(i * 5);
			cout << v1;
			stop
		}
	stop
	cout << "----------------------------------------------------------------------------------------------------" << endl;
		for (size_t i = 0; i < N; i++)//Добавляет по 2 до чётного количества начиная с 4
		{
			v2.push_back(i * 5);
			cout << v2;
			stop
		}
	stop

	/*
	!!! shrink_to_fit - Уменьшение емкости вектора.
	Для любого вектора из предыдущего задания требуется уменьшить емкость до size.
	*/
	cout << "----------------------------------------------------------------------------------------------------" << endl;
	for (size_t i = 0; i < N; i++)
	{
		v1.shrink_to_fit();
		cout << v1;
		stop
	}
	stop
	cout << "----------------------------------------------------------------------------------------------------" << endl;
	for (size_t i = 0; i < N; i++)
	{
		v2.shrink_to_fit();
		cout << v2;
		stop
	}
	stop

		//Создание "двухмерного вектора" - вектора векторов
		//Задан одномерный массив int ar[] = {11,2,4,3,5};
		//Создайте вектор векторов следующим образом:
		//вектор vv[0] - содержит 11 элементов со значением 11
		//vv[1] - содержит 2,2
		//vv[2] - содержит 4,4,4,4
		//...
		//Распечатайте содержимое такого двухмерного вектора по строкам

	stop

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//Вставка элемента последовательности insert().
			//В вектор vChar2 вставьте в начало вектора символ только при
			//условии, что в векторе такого еще нет.



			//Вставьте перед каждым элементом вектора vChar2 букву 'W'



		///////////////////////////////////////////////////////////////////
			//Напишите функцию, которая должна удалять только повторяющиеся последовательности.
			//Например: было - "qwerrrrty12222r3", стало - "qwety1r3"




		stop

		///////////////////////////////////////////////////////////////////

			//Удаление элемента последовательности erase()
			//Напишите функцию удаления из любого вектора всех дублей 





		///////////////////////////////////////////////////////////////////
			//Создайте новый вектор таким образом, чтобы его элементы стали
			//копиями элементов любого из созданных ранее векторов, но расположены
			//были бы в обратном порядке






		///////////////////////////////////////////////////////////////////

			//Задание 1. Списки. Операции, характерные для списков.
			//Создайте пустой список из элементов Point - ptList1 и наполните
			//его значениями с помощью методов push_back(),
			//push_front, insert()


			//Напишите шаблон функции, которая будет выводить элементы
			//ЛЮБОГО КОНТЕЙНЕРА на печать. Проверьте работу шаблона на контейнерах
			//vector и list. Подсказка - хотелось бы увидеть тип контейнера.


			//Сделайте любой из списков "реверсивным" - reverse()


			//Создайте список ptList2 из элементов Point таким образом, чтобы он стал 
			//копией вектора элементов типа Point, но значения элементов списка располагались
			//бы в обратном порядке 



			//Отсортируйте списки  ptList1 и ptList2 - методом класса list - sort()
			//по возрастанию.
			//Подумайте: что должно быть перегружено в классе Point для того, чтобы
			//работала сортировка





		stop

		//Объедините отсортированные списки - merge(). Посмотрите: что
		//при этом происходит с каждым списком.


		stop

		//Исключение элемента из списка - remove()
		//Исключите из списка элемент с определенным значением.
		//Подумайте: что должно быть перегружено в классе Point?


		//Исключение элемента из списка, удовлетворяющего заданному условию:
		//любая из координат отрицательна - remove_if(). 


		//Исключение из списка подряд расположенных дублей - unique(). 

		stop

		///////////////////////////////////////////////////////////////////
			//Задание 2.Очередь с двумя концами - контейнер deque

			//Создайте пустой deque с элементами типа Point. С помощью
			//assign заполните deque копиями элементов вектора. С помощью
			//разработанного Вами в предыдущем задании универсального шаблона
			//выведите значения элементов на печать



			//Создайте deque с элементами типа MyString. Заполните его значениями
			//с помощью push_back(), push_front(), insert()
			//С помощью erase удалите из deque все элементы, в которых строчки
			//начинаются с 'A' или 'a'




		return 0;
}